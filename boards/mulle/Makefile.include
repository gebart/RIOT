# define the cpu used by the Mulle board
export CPU = k60

### CPU part number (must have a specific linker script for each part)
# Note that MK60DN256ZVLL10 (version 1.x) and MK60DN256VLL10 (version 2.x, no Z)
# only differ in some register locations etc, not in the actual memory layout,
# so it is safe to use the same linker script for both version 1.x and version
# 2.x silicon.
# The linker script needs to know the flash and RAM sizes of the device.

export GDBPORT ?= 3333

# MULLE_SERIAL is used to select which specific Mulle board we are compiling for.
# This was called MULLE_BOARD_SERIAL_NUMBER previously, renamed because
# MULLE_BOARD_SERIAL_NUMBER is too long to type.
ifdef MULLE_SERIAL
  ifeq "200" "$(word 1, $(sort 200 $(MULLE_SERIAL)))"
    # >= 100
    ifneq "220" "$(word 1, $(sort 220 $(MULLE_SERIAL)))"
      # < 220
      CPU_MODEL = K60DN256ZVLL10
    else
      # >= 220
      CPU_MODEL = K60DN512VLL10
    endif
  endif
  CFLAGS += -DMULLE_SERIAL=$(MULLE_SERIAL)
endif

ifeq ($(CPU_MODEL),)
  CPU_MODEL = K60DN512VLL10
endif

export CPU_MODEL

# Host OS name
OS := $(shell uname)

# OpenOCD settings for Mulle board.
# Try to determine which version of the OpenOCD config file we should use.
# Specify PROGRAMMER_VERSION or PROGRAMMER_SERIAL to choose a specific programmer board.
ifeq ($(PROGRAMMER_VERSION),)
  ifneq ($(PROGRAMMER_SERIAL),)
    # Makefile-way of comparing numbers, using lexicographical sorting since we don't have any arithmetic comparisons.
    # Programmers with serial 100 -- 148 are version 0.60
    # Programmers with serial 301 -- 330 are version 0.70
    ifeq "100" "$(word 1, $(sort 100 $(PROGRAMMER_SERIAL)))"
      # >= 100
      ifneq "149" "$(word 1, $(sort 149 $(PROGRAMMER_SERIAL)))"
        # < 149
        PROGRAMMER_VERSION = 0.60
      else
        # >= 149
        PROGRAMMER_VERSION = 0.70
      endif
    endif
  endif
  # Default to version 0.60 programmer for now.
  PROGRAMMER_VERSION ?= 0.60
endif

OOCD_BOARD_FLAGS = -f '$(RIOTBOARD)/$(BOARD)/dist/openocd/mulle-programmer-$(PROGRAMMER_VERSION).conf'

# Add serial matching command
ifneq ($(PROGRAMMER_SERIAL),)
  OOCD_BOARD_FLAGS += -c 'ftdi_serial $(PROGRAMMER_SERIAL)'

  ifeq ($(PORT),)
    # try to find tty name by serial number, only works on Linux currently.
    ifeq ($(OS),Linux)
      PORT :=$(shell $(RIOTBOARD)/dist/tools/ftdi/find-tty.sh $(PROGRAMMER_SERIAL))
    endif
  endif
endif

ifeq ($(PORT),)
    ifeq ($(OS),Linux)
      PORT := /dev/ttyUSB0
    else ifeq ($(OS),Darwin)
      PORT := $(shell ls -1 /dev/tty.SLAB_USBtoUART* | head -n 1)
    endif
endif

# TODO: add support for windows as host platform
ifeq ($(PORT),)
  $(info CAUTION: No terminal port for your host system found!)
endif
export PORT

# Default optimization level, possible to override from command line.
OPTIMIZATION ?= -Os

# Target triple for the build. Use arm-none-eabi if you are unsure.
export TARGET_TRIPLE ?= arm-none-eabi

# Toolchain prefix, defaults to target triple followed by a dash, you will most likely not need to touch this.
export PREFIX  ?= $(if $(TARGET_TRIPLE),$(TARGET_TRIPLE)-)
export GDBPREFIX ?= $(PREFIX)

# define tools used for building the project
export OPENOCD ?= openocd
export GDB ?= $(GDBPREFIX)gdb
export CC = $(PREFIX)gcc
export CXX = $(PREFIX)g++
export AR = $(PREFIX)ar
export AS = $(PREFIX)as
export LINK = $(PREFIX)gcc
export SIZE = $(PREFIX)size
export OBJCOPY = $(PREFIX)objcopy
export TERMPROG ?= $(RIOTBASE)/dist/tools/pyterm/pyterm
export FLASHER ?= $(OPENOCD)
export DEBUGGER ?= $(GDB)
export DEBUGSERVER ?= $(OPENOCD)
export RESET ?= $(OPENOCD)

# define build specific options
CPU_USAGE = -mcpu=cortex-m4
FPU_USAGE = -mfloat-abi=soft -msoft-float
export CFLAGS += -ggdb -g3 \
    -std=gnu99 \
    $(OPTIMIZATION) \
    -Wall -Wstrict-prototypes -Werror=implicit-function-declaration \
    $(CPU_USAGE) \
    $(FPU_USAGE) \
    -mlittle-endian \
    -mthumb \
    -nostartfiles \
    -fno-common \
    -fshort-enums \
    -ffunction-sections -fdata-sections \
    -fno-builtin \
    -fno-strict-aliasing
export CXXFLAGS += -ffunction-sections -fdata-sections -fno-builtin
export ASFLAGS += -ggdb -g3 $(CPU_USAGE) $(FPU_USAGE) -mlittle-endian
export LINKFLAGS += -g3 -ggdb -std=gnu99 $(CPU_USAGE) $(FPU_USAGE) -mlittle-endian -static -mthumb -nostartfiles -Wl,--fatal-warnings
export LINKFLAGS += -L$(LINKERSCRIPTPATH) -T$(LINKERSCRIPT)
export OFLAGS ?= -O binary

ifdef BUILD_WITH_CLANG
ifneq ($(BUILD_WITH_CLANG),0)
export CFLAGS += -target $(TARGET_TRIPLE) -ffreestanding
export CC       = clang
export LD       = clang
export LLVMPREFIX ?= llvm-
export AS       = $(LLVMPREFIX)as
export AR       = $(LLVMPREFIX)ar
export NM       = $(LLVMPREFIX)nm
# There is no LLVM linker yet, use binutils.
#export LINKER   = $(LLVMPREFIX)ld
# objcopy does not have a clear substitute in LLVM
#export OBJCOPY  = $(LLVMPREFIX)objcopy
export OBJDUMP  = $(LLVMPREFIX)objdump
# LLVM lacks a binutils strip tool as well...
#export STRIP    = $(LLVMPREFIX)strip
export SIZE     = $(LLVMPREFIX)size
# llvm-ar does not support the f modifier (anymore, since r186078) set in the
# default Contiki Makefile.include
export AROPTS   = rcv

# Since Clang is not installed as a separate instance for each crossdev target
# we need to tell it where to look for platform specific includes (Newlib
# headers instead of Linux/Glibc headers.)
# On GCC this is done when building the cross compiler toolchain so we do not
# actually need to specify the include paths for system includes.
NEWLIB_INCLUDES ?= \
  -isystem /usr/arm-none-eabi/include \
  -isystem /usr/arm-none-eabi/usr/include \
  #

endif
endif

export CFLAGS += $(NEWLIB_INCLUDES)


FFLAGS ?= $(OOCD_BOARD_FLAGS)
FFLAGS += \
    -c 'tcl_port 0' \
    -c 'gdb_port 0' \
    -c 'telnet_port 0' \
    -c 'init' \
    -c 'targets' \
    -c 'reset halt' \
    -c 'flash write_image erase bin/$(BOARD)/$(APPLICATION).elf 0x00000000 elf' \
    -c 'verify_image bin/$(BOARD)/$(APPLICATION).elf' \
    -c 'reset run' \
    -c 'shutdown'

export FFLAGS

DEBUGSERVER_FLAGS ?= $(OOCD_BOARD_FLAGS)
DEBUGSERVER_FLAGS += \
    -c 'tcl_port 0' \
    -c 'gdb_port $(GDBPORT)' \
    -c 'telnet_port 0' \
    -c 'init' \
    -c 'targets' \
    -c 'reset halt'

export DEBUGSERVER_FLAGS

RESET_FLAGS ?= $(OOCD_BOARD_FLAGS)
RESET_FLAGS += \
    -c 'tcl_port 0' \
    -c 'gdb_port 0' \
    -c 'telnet_port 0' \
    -c 'init' \
    -c 'reset run' \
    -c 'shutdown'

export RESET_FLAGS

DEBUGGER_FLAGS ?= -x $(RIOTBOARD)/$(BOARD)/dist/gdb.conf
DEBUGGER_FLAGS += \
    -ex 'tar ext :$(GDBPORT)' \
    $(BINDIR)/$(APPLICATION).elf

export DEBUGGER_FLAGS

export TERMFLAGS += -p "$(PORT)"

# use newlib nano-specs if available
ifeq ($(shell $(LINK) -specs=nano.specs -E - 2>/dev/null >/dev/null </dev/null ; echo $$?),0)
export LINKFLAGS += -specs=nano.specs -lc -lnosys
endif

# export board specific includes to the global includes-listing
export INCLUDES += -I$(RIOTBOARD)/$(BOARD)/include

include $(RIOTBOARD)/$(BOARD)/Makefile.dep
